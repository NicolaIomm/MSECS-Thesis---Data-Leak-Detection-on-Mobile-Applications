\chapter{Fundamentals}
	\par This chapter is dedicated to illustrate some fundamental knowledge in order to fully understand the work I have done while investigating specific applications. Some of them are technologies arised in last ten years, improving not only the efficiency but also the stability and portability of the standard development of mobile applications. \newline
	Generally Android mobile applications are client implementations for specific services. The scenario is therefore the classic client-server communication model where each client interacts with one or more server. \newline
	\par First of all client and server must establish a connection between them, hopefully a \textit{secure connection}. This is the first topis explained in this section. Client and server, that means mobile application and application server, agree to find a secure way to communicate each other. 
	\par Once the connection is established there are lots of ways in which an application can send information. This is the problem of the data serialization. Informations can be represented using different Interface Description Languages (IDL). Starting from the classic JSON or XML format, passing through binary. Each representation has advantages and disadvantages. In particular there is a section dealing with an IDL that is widely used in mobile application, that is \textit{Protocol Buffer}.
	\par After having described the interation of a standard mobile application, there is a section explaining the concept of \textit{gRPC}. As I said most of the mobile applications reflect the client-server paradigm. It is modern framework able to delegate some procedure in the client to the server, improving performance and portability of the application service.
	\par Finally the last section of this chapter deals with a new network procol called \textit{QUIC}, a modern evolution of the HTTP/2 protocol used by most of the recent applications.
	
	\section{HTTPS: HTTP over TLS}
		\par As stated in the online documentation for Android Developers~\cite{android_dev_tips} it is a good practice to protect applications data using the \textbf{Transport Layer Security (TLS)} along with the standard HTTP protocol. \newline
		TLS is a protocol designed to provide communications security over a computer network.  
		It provides \textit{confidentiality}, \textit{authentication} and \textit{integrity} meaning that: data is encrypted for third parties, ensure that both parties actually are who they pretend to be, ensure that data is not modified in the transit.
		\par A server (or web application) that wants to use TLS must have installed an \textbf{SSL certificate} on the machine. This certificate is released by a \textbf{Certificate Authority (CA)} for a specific domain, and contains important informations on the owner of that domain together with the public key of the server.  
		\par Every time a client wants to establish a connection with a server using TLS, the TLS Handshake procedure is issued.	
		\par There are also some mitigations Android mobile application developer can use in order to limitate authority checks
		
		\subsection{SSL/TLS Handshake}
			\par During the TLS handshake both mobile application and server exchange informations to set up a bidirectional encrypted connection. For this reason TLS version (1.0, 1.2, 1.3, etc) and cryptographic suite are agreed. Moreover the client verifies the authenticity of the server basing on its certificate. Finally both the endpoints will generate session keys to encrypt and decrypt the messages they will exchange each other. Once data are encrypted, they are signed with a Message Authentication Code (MAC), so that the receiver can verify the integrity of the data sent over the network.
			\begin{figure}[ht]
				\centering
				\includegraphics[width=0.8\textwidth]{images/tcp-tls-handshake.png}
				\caption{TCP Handshake and TLS Handshake communication flow needed to set up a secure connection. \cite{image_tcp_tls_handshake}}
				\label{fig:tcp_tls_handshake}
			\end{figure}
			\par From the performance point of view, the whole process of the TLS handshake needs both the endpoints to communicate before the data are actually transmitted over the network. In particular in the TLS versions < 1.3, two round trip time are needed to set up the whole connection \textit{(110ms)}. This amount of time added to the standard TCP three-way-handshake \textit{(50ms)} to establish the session between client and server, results in average in less then \textit{0.2 seconds} spent only to set up a secure connection without actually sending any application data yet. 
			\newline
 			As I said TLS makes possible to exchange information over a non-secure channel by providing confidentiality, authentication and integrity.  
			
		\subsection{Certificate Verification}
		\label{subsec:certificate_verification}
			\par A procedure I would like to stress is the certificate validation routine that happens at the really start of every TLS handshake. At the moment the client wants to establish a connection with the server, it needs the certificate to check the server is the actual endpoint the client want to talk with. The first thing the client does is to check that the certificate showed by the server is not expired, and that the server domain name matches with the one reported in the certificate. The next step performed by the client is to verify that the certificate has been signed by the certificate authority that authorized it. This procedure is done by verifying that the issuer's CA name matches the owner's CA name at the above level, and using the owner's CA signature and public key to verify the certificate is properly signed. The process is repeated until a CA trusted by the client is met, usually a root CA.
			\begin{figure}[ht]
				\centering
				\includegraphics[width=0.8\textwidth]{images/tls-certificate-verification.png}
				\caption{TLS Certificate verification chain. \cite{image_tls_certificate_verification}}
				\label{fig:tls_certificate_verification}
			\end{figure}
			\par Usually certificates are bought by companies that wants to implement a secure connection with their clients. In this way the certificate obtained by the server is inserted in the tree of certificates, and every client can verify its authenticity. Note also that every machine can generate a self-signed certificate. What is indeed important is checking if the server certificate is linkable to a trusted Certificate Authority. \newline
			\par The Android operative system handles by itself a list of trusted certificates. These certificates belong to two categories: system certificates and user certificates. \newline
			\textit{System certificates} are used by default to verify all other certificates. So if we are using an application trying to connect to an application service, if the certificate obtained by the web service is traceable to one certificate already present in the system store, then the certificate is accepted and the connection is established. Notice that since the release of Android 7 Nougat, it is impossible to install any CA at system level without having root privileges on the device. \newline
			On the other way \textit{user certificates} are installable even at user level, and are used to verify certificates when directly expressed by the application.
			
		\subsection{Man-in-The-Middle}
		\label{subsec:mitm}
			\par \textbf{Man-In-The-Middle (MITM)} is an attack able to disrupt the security properties delivered by the TLS protocol. As the name suggests the attacker positions himself between the server and the client. The attacker acts like a proxy server intercepting every connection incoming from the client, pretending to be the real server, and forwarding them to the real server, pretending to be the real client. 
			\par On one side, at the moment of the TLS handshake, the client verifies the identity of the server, so the attacker needs to reproduce the handshake with the client in order to let it trust the attacker. As described in the last section, the authenticity check is performed through the exhibition of the server certificate. In this case the client needs to trust the certificate of the attacker. After having checked the identity of the server, the TLS handshake can continue following the standard procedure: client and attacker agree on a pre-master shared key and the encrypted communication will take place.
			\par On the other side the attacker needs to act as the real client for the server, so that every connection intercepted will be redirected to the server, and every response obtained will be delivered to the client. This is made possible by starting a new connection between attacker and server. The attacker will authenticate the server by checking its certificate and completing the standard TLS handshake with it. \newline
			At this point the attacker has performed two different TLS handshakes, one with the client faking to be the server, and one with the server faking to be the client. The man in the middle is now able to read messages sent or received from the client and forward or deliver them to the server. \newline
			\par A man-in-the-middle attack is what made possible the analysis of the communication protocol of every application I investigated. After having \textit{placed} ourselves inbetween client and server we will be able to understand what exactly is the protocol adopted by an android application and analyze each message looking for a possible leak detection of users personal data. For more specifics on how I performed a MitM attack for my case studies, read the chapter \textit{Testing Environments}, sections \textit{HttpToolkit}[Section \ref{sec:http_toolkit}] and \textit{BurpSuite}[Section \ref{sec:burp_suite}].
			
		\subsection{SSL Certificate Pinning}
			\par If the MitM attack results in the loss of authenticity in an HTTPS communication, the \textbf{SSL Certificate Pinning} is an hardening process that can be adopted in order to deliver an additional layer of security to the software. Pinning certificates or public keys is a countermeasure that allow web servers to control the risk of man-in-the-middle attacks or CA compromise. 
			\par The whole process of certificate verification described in the previous section is skipped, the application will indeed only validate certificates or public keys that are \textit{pinned} to the application. A MitM attacker will not be able to intercept messages anymore. The connection will be blocked right in the middle of client's and attacker's TLS handshake. The application implementing a certificate pinning method in fact will not trust anymore the attacker's certificate, and the connection will be dropped by the attacker's proxy.
			\par There are two ways of implementing this hardening technique. The first one is by \textit{preloading} the public key or certificate in the client at development time, so that every fake server trying to connect to the client is rejected during the TLS handshake phase. The second one happens at runtime by installing the \textit{pin} in the client once upon the connection is established by using the HTTP Public Key Pinning (HPKP) header, indicating the public key and the max age of validity for that specific pin. This second approach has been adopted by Chrome and Firefox for their browsers, but after some years new security issues has been discovered about it. Indeed in case of bad implementation (for example a pin of an incorrect public key) could bring to denial of service, but even in case of compromised server the consequences can be devastating for a longer time if HPKP is implemented, a bad pin might be established from an attacker that had the control of the server (HPKP Suicide~\cite{HPKP_suicide}). For this reason the public key pinning is now highly discouraged for web browsers. \newline
			\par In Android application SSL certificate pinning is a solution still able to protect from MitM attacks. The implementation is generally done by pinning a specific certificate inside the application logic at development time. There are multiple ways to implement a certificate pinning in Android as explained in \cite{android_ssl_pinning}. Among them two approaches can be identified: 
			\begin{enumerate}
				\item basing on \textit{Network Security Configuration}: A pretty simple certificate pinning implementation made possible by specifying a \textit{<domain-config> tag} in the network security configuration file present in the application. A \textit{pin-set} of \textit{pin} can be specified for the whole application.
				\item basing on the \textit{network library}: Many different network libraries exist for Android application (i.e. \textit{OkHttp}, \textit{Retrofit}, \textit{Volley}, and so on). Each one of them provide methods to skip the standard certificate validation procedure and implement the certificate pinning procedure.
			\end{enumerate}
			
		\subsection{Certificate Transparency}
		\label{subsec:certification_transparency}
			\par \textbf{Certificate Transparency} (CT) is a security standard adopted by browsers for monitoring and logging discrepancies in the certificate verification procedure. The whole system is manteined by a set of certificate logs handled by Certification Authorities and many browsers. These logs assume the form of \textit{Merkle trees} (also noticed as \textit{hash tree}), they are publicly verifiable, in append-only mode. The goal of this standard is to keep track of all valid certificates ever issued for a specific domain. \newline
			\par	This is the scenario: a domain owner implementing a web service requests a new certificate from a CA. Before releasing the new certificate, it submits the \textit{hash digest} of that certificate to one or more certificate logs, receiving a \textit{Signed Certificate Timestamp (SCT)} signed by the log provider. Once signed, the CA can now send back the certificate with embedded the SCT to the domain owner asking for the certificate. Every HTTPS connection to that web service will be served using that certificate. When a user wants to use the web service, browsers or mobile apps will query the trusted certificate log to find a record matching with the SCT of the certificate received by the web service. \newline
			\par In Android operative system, an example of application implementing the Certification Transparency mechanism is the Chrome browser. As we said above (see Certificate Verification [Section \ref{subsec:certificate_verification}]) Android certificates can be placed at system level or user level. Every application will use by default the system store to verify others certificates, and so does Chrome, if not specified differently. This application will choose whether to use the Certificate Transparency or not, basing on which store the certificate root is installed. When a certificate showed by any web service it is checked, if the root certificate met is present in the system certificates store then Chrome decides to also verify the Certificate Transparency requirement. On the other way if we are testing a web service showing a certificate that is inside the user certificates store, then the Certificate Transparency procedure is not applied.\newline 
			
	\section{Protocol Buffers}
		\par 

	\section{gRPC}
		\par 

	\section{QUIC Protocol}
		\par 
	